
## 跳表

#### 概念
是基于有序链表的扩展，提取出链表中关键节点作为索引的多层链表，以空间换时间提高查找性能。

#### 性质
 1. 由很多层结构组成，level是通过一定的概率随机产生的。
 2. 每一层都是一个有序的链表，默认是升序
 3. 最底层(Level 1)的链表包含所有元素。
 4. 如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现。
 5. 每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素

#### 时间及空间复杂度

| 算法 | 平均 | 最差 |
| ------ | ------ | ------ |
| 空间 | O(n) | O(n log n) |
| 搜索 | O(log n) | O(n) |
| 插入 | O(log n) | O(n) |
| 删除 | O(log n) | O(n) |

#### 图示

![skip_list_add](./img/skip_list_add.gif)


#### 插入
1. 新节点和各层索引节点逐一比较，确定原链表的插入位置。O（logN）
2. 把索引插入到原链表。O（1）
3. 利用抛硬币的随机方式，决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止。O（logN）

#### 删除
1. 自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点。O（logN）
2. 删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外）。O（logN）

#### 优点
1.其效率可比拟平衡数（对于大多数操作都在O(log n)）

2.实现复杂度低(只要熟悉链表的基本操作，和对跳表原理的理解)

3.跳跃列表不像某些传统平衡树数据结构那样提供绝对的最坏情况性能保证，因为用来建造跳跃列表的扔硬币方法总
有可能（尽管概率很小）生成一个糟糕的不平衡结构。但是在实际中它工作的很好，随机化平衡方案比在平衡二叉
查找树中用的确定性平衡方案容易实现。跳跃列表在并行计算中也很有用，这里的插入可以在跳跃列表不同的部分
并行的进行，而不用全局的数据结构重新平衡。     ——————         wiki

#### 应用
1.Redis的sorted set

2.LevelDB的memtable

3.Lucene

4.ElasticSearch

......